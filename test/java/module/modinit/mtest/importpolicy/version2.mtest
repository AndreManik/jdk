#
# Verify that the custom import policy is invoked 
# and that it cannot pick a version of m2 that does not match the
# declared version constraint
#
>>> begin module m1
> annotations
@MainClass("m1.MainA")
@ImportPolicyClass("m1.ImportPolicyImpl")
@ImportModules({
    @ImportModule(name="java.se"),
    @ImportModule(name="m2", version="1.4+")
})
> export
m1.Main
>> begin class m1.MainA
	if (ImportPolicyImpl.CALLED == false) {
	    throw new Exception("Import policy not called");
	}
	new m2.MainB().run("from m1");
	if (m2.MainB.V != 1) {
	    throw new Exception("Wrong version of m2");
	}
>> end class
>> begin class m1.ImportPolicyImpl
> super
implements ImportPolicy
> body
    static volatile boolean CALLED;

    public List<ModuleDefinition> getImports(ModuleDefinition moduleDef, 
	    Map<String,VersionConstraint> constraints, ImportPolicy defaultImportPolicy)
	    throws UnsatisfiedDependencyException {
	CALLED = true;
	Repository rep = moduleDef.getRepository();
	List<ModuleDefinition> mds = new ArrayList<ModuleDefinition>();
	mds.add(rep.find("java.se"));
	mds.add(rep.find("m2", VersionConstraint.valueOf("1.2")));
	return mds;
    }
>> end class
>>> end module
>>> begin module m2
> annotations
@Version("1.2")
@ImportModules({
    @ImportModule(name="java.se")
})
> export
m2.MainB
>> begin class m2.MainB
> body
    public static int V = 1;
>> end class
>>> end module
>>> begin module m2
> annotations
@Version("1.5")
@ImportModules({
    @ImportModule(name="java.se")
})
> export
m2.MainB
>> begin class m2.MainB
> body
    public static int V = 2;
>> end class
>>> end module
>>> begin test m1
exception ModuleInitializationException
>>> end test
